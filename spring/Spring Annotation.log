@Component / @Service / @Repository / @Controller
설정 위치: 클래스 선언부 앞
<context:component-scan base-package="xxx"/> 태그를 설정파일에 추가하면 @Component / @Service / @Repository / @Controller 해당 어노테이션이 적용된 클래스를 빈으로 등록하게 된다
범위는 디폴트로 singleton이며 @Scope를 사용하여 지정할 수 있다. xxx 패키지 하위에 위 어노테이션으로 선언된 클래스를 bean으로 자동 등록한다. bean의 이름은 해당 클래스명(첫글자는 소문자)이 사용된다.
@Component
@Scope(value="prototype")
public class Worker {}

<context:annotation-config/> 태그는 어노테이션과 관련해서 다음의 BeanPostProcessor를 함께 등록 한다.
@Required(RequiedAnnotationBeanPostProcessor)
@Autowired(AutowiredAnnotationBeanPostProcessor)
@Resource, @PostConstruct, @PreDestory(CommonAnnotationBeanPostProcessor)
@Configuration(ConfigurationClassPostProcessor)

@Required
설정 위치: setter 메서드 앞
Required 어노테이션은 필수 프로퍼티임을 명시하는 것으로 필수 프로퍼티를 설정하지 않을 경우 빈 생성시 예외를 발생시킨다.

@Autowired
설정 위치: 생성자, 필드, 메서드(setter메서드가 아니여도 된다) 앞
의존관계를 자동설정할 때 사용하며 타입을 이용하여 의존하는 객체를 삽입해 준다. 그러므로 해당 타입의 Bean 객체가 존재하지 않거나 또는 2개 이상 존재할 경우 스프링은 예외를 발생시키게 된다.

@Autowired(required=false)
@Autowired 어노테이션을 적용한 프로퍼티 중 반드시 설정할 필요가 없는 경우에 false값을 주어 프로퍼티가 존재하지 않더라도 스프링이 예외를 발생하지 않도록 한다. 기본값은 TRUE.

@Qualifier
설정 위치: @Autowired 어노테이션과 함께 사용된다.
@Qualifier 어노테이션은 @Autowired의 목적에서 동일 타입의 Bean 객체가 2개 이상 존재할 경우 특정빈을 삽입할 수 있게 설정한다. 

@Resource
@Autowired와 흡사하지만 @Autowired는 타입으로(by type), @Resource는 이름으로(by name)으로 연결한다는 점이 다르다.

@PostConstruct
설정 위치: 초기화 작업 수행 메서드 앞
의존하는 객체를 설정한 이후에 초기화 작업을 수행하기 위해 사용한다. 스프링에 의해 인스턴스가 생성된 후 어노테이션이 적용된 메서드가 호출된다.
init-metohod

@PreDestory
설정 위치: 해당 작업 메서드 앞
컨테이너에서 객체를 제거하기 전에 해야할 작업을 수행하기 위해 사용한다
destroy-method

@Service
@Service를 적용한 Class는 비지니스 로직이 들어가는 Service로 등록이 된다.
Controller에 있는 @Autowired는 @Service("xxxService")에 등록된 xxxService와 변수명이 같아야 하며,
Service에 있는 @Autowired는 @Repository("xxxDao")에 등록된 xxDao와 변수명이 같아야 한다.

@Repository
@Repository는 일반적으로 DAO(클래스 앞)에 사용되며 DB Exception을 DataAccessException으로 변환한다.

<!-- Enables the Spring MVC @Controller programming model -->
<annotation-driven />
<!-- task 네임스페이스의 @Scheduled annotation 활성화 -->
<task:annotation-driven scheduler="jobScheduler" />

@Controller
spring MVC의 Controller 클래스 선언을 단순화시켜준다. 스프링 컨트롤러, 서블릿을 상속할 필요가 없으며, @Controller로 등록된 클래스 파일에 대한 bean을 자동으로 생성해준다.

[Controller 메서드의 파라미터 타입]
1)  HttpServletRequest, HttpServletResponse, HttpSession : Servlet API
2)  java.util.Locale : 현재 요청에 대한 Locale 정보(ex. ko_KR, en_US)
3)  InputStream, Reader : 요청 컨텐츠에 직접 접근할 때 사용
4)  OutputStream, Writer : 응답 컨텐츠를 생성할 때 사용
5)  @PathVariable 어노테이션 적용 변수 : URL 템플릿 변수에 접근할 때 사용
6)  @RequestParam 어노테이션 적용 변수 : HTTP 파라미터와 매핑 = ServletRequest.getParameter(java.lang.String name)와 같은 역할
7)  @RequestHeader 어노테이션 적용 변수 : HTTP 헤더 매핑
8)  @CookieValue 어노테이션 적용 변수 : HTTP 쿠키 매핑
9)  @RequestBody 어노테이션 적용 변수 : HTTP RequestBody에 접근할 때 사용. HttpMessage Converter를 이용해 RequestBody 데이터를 해당 타입으로 변환한다.
10) Map, Model, ModelMap : 뷰에 전달할 모델 데이터를 설정할 때 사용
11) SessionStatus : 폼 처리를 완료 했음을 처리하기 위해 사용. @SessionAttribute를 명시한 session 속성을 제거하도록 이벤트를 발생시킨다.

[Controller 메서드의 리턴 타입]
1)  ModelAndView : 뷰 정보 및 모델 정보를 담고 있는 ModelAndView 객체
2)  Model : 뷰에 전달할 객체 정보를 담고 있는 Model을 리턴한다. 이때 뷰 이름은 요청 URL로부터 결정된다. (RequestToViewNameTranslator를 통해 뷰 결정)
3)  Map, ModelMap : 뷰에 전달할 객체 정보를 담고 있는 Map 혹은 ModelMap을 리턴한다. 이때 뷰 이름은 요청 URL로부터 결정된다. (RequestToViewNameTranslator를 통해 뷰 결정) 
4)  String : 뷰 이름을 리턴한다.
5)  View 객체 : View 객체를 직접 리턴. 해당 View 객체를 이용해서 뷰를 생성한다.
6)  void : 메서드가 ServletResponse나 HttpServletResponse 타입의 파라미터를 갖는 경우 메서드가 직접 응답을 처리한다고 가정한다. 그렇지 않을 경우 요청 URL로부터 결정된 뷰를 보여준다. (RequestToViewNameTranslator를 통해 뷰 결정)
7)  @ResponseBody 어노테이션 적용 : 메서드에서 @ResponseBody 어노테이션이 적용된 경우, 리턴 객체를 HTTP 응답으로 전송한다. HttpMessageConverter를 이용해서 객체를 HTTP 응답 스트림으로 변환한다.

A. @RequestMapping
URL을 컨트롤러의 메서드와 매핑할 때 사용하는 스프링 프레임워크의 어노테이션이다.
메서드 내에서 viewName을 별도로 설정하지 않으면 @RequestMapping의 path로 설정한 URL이 그대로 viewName으로 설정된다.

B. @RequestParam
RequestParam annotation은 key=value 형태로 화면에서 넘어오는 쿼리스트링 혹은 폼 데이터 Body를 메서드의 파라미터로 지정한다. 대체로 파라미터의 개수가 적을때 사용한다.

C. @RequestBody
@RequestBody 어노테이션이 적용된 파라미터는 HTTP Request body의 내용이 전달된다.

D. @ResponseBody
메서드에 @ResponseBody를 적용한 후 문자열을 리턴하면 그 값은 HTTP response header가 아니라 HTTP response body에 쓰여진다.
또한 @ResponseBody가 적용된 컨트롤러는 context에 설정된 resolver를 무시한다.

E. @PathVariable
URL의 일부를 파라미터 혹은 변수로 사용한다.

F. @ModelAttribute
다른 말로 커맨드 오브젝트라고도 불리는데 그 이유는 클라이언트가 전달하는 파라미터를 1:1로 전담 프로퍼티에 담아내는 방식이 커맨드 패턴 그 자체이기 때문이다.

G. @SessionAttributes
항상 클래스 상단에 위치하며 해당 어노테이션이 붙은 컨트롤러는 @SessionAttributes("세션명")에서 지정하고 있는 "세션명"을 @RequestMapping으로 설정한 모든 뷰에서 공유하고 있어야 한다.
@ModelAttributes를 붙인 메서드를 이용할 것을 적극 권장한다. 이 메서드는 해당 컨트롤러로 접근하려는 모든 요청에 @ModelAttribute가 붙은 메서드의 리턴 값을 설정된 모델명으로 자동 포함해주는 역할을 담당해준다.
물론 이미 동일한 이름의 모델이 생성되었있다면 위의 메서드 값은 포함되지 않으며 오로지 설정한 모델명과 일치하는 객체가 존재하지 않는 경우에만 메서드의 리턴 값을 서버의 응답과 함께 클라이언트에게 전송하는 역할을 담당한다.

@RestController
Spring 4.0은 @Controller와 @ResponseBody 을 합쳐놓은것 이상의 역할을 수행하는@RestController를 추가했습니다.
컨트롤러 클래스에 @RestController 어노테이션을 작성함으로써 더 이상 @ResponseBody를 모든 요청 매핑 메소드에 추가 할 필요가 없다.

@Configuration
A=B는 같은 표현식이다.
A.
@Configuration
public class HelloWorldConfig {
   @Bean 
   public HelloWorld helloWorld(){
      return new HelloWorld();
   }
}

B.
<beans>
   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld" />
</beans>

@ExceptionHandler
컨트롤러의 요청처리 메소드에 의해 발생하는 예외처리들을 구체화할 수 있다. 
@ExceptionHandler({SQLException.class,DataAccessException.class})
@ExceptionHandler(CustomGenericException.class)
@ExceptionHandler(Exception.class)

@Cacheable(value="movieFindCache", key="#name")
설정 위치: 대상 메서드 앞, 주로 DAO 클래스의
This method only executed once, subsequent call will get the object from cache.

@Value("${kosORD}")
프로퍼티값 참조할 때 사용
<context:property-placeholder location="classpath:env-*.properties"/>
@Value("${kosORD}")
private String kosORD;

javax.xml.bind.annotation (JAXB)
@XmlRootElement : 클래스 앞에 사용
@XmlElement
@XmlElementWrapper is often useful with this, as it allows you need to group them
@XmlAttribute 
@XmlAccessorType(XmlAccesType.FIELD) : 클래스 앞에 사용하며 xml로 만들 범위를 결정. 필드는 모두 추출한다. XmlAccesType.NONE: 어노테이션 한 것만 추출한다.
@XmlType : 클래스 앞에 사용, ex) @XmlType(propOrder={"street", "city" , "state", "zip", "name" })

AspectJ PointCut 표현식
A. 수식어패턴 : public, private 등등의 수식어를 명시, 생략 가능
B. 리턴타입 : 리턴 타입을 명시
C. 클래스이름, 이름패턴 : 클래스 이름 및 메서드이름을 패턴으로 명시
D. 파라미터패턴 : 매칭될 파라미터에 대해 명시
E. '*' : 모든 값을 표현
F. '..' : 0개 이상을 의미
ex) execution(public void set*(..))
=> 리턴 타입이 void이고 메서드 이름이 set으로 시작하며, 파라미터가 0개 이상인 메서드
ex) execution(* sp.aop.service.*.*())
=> sp.aop.service 패키지의 파라미터가 없는 모든 메서드
ex) execution(* sp.aop.service..*.*(..))
=> sp.aop.service 패키지 및 하위 패키지에 있는 파라미터가 0개 이상인 모든 메서드
ex) execution(* get*(*))
=> get으로 시작하고 1개의 파라미터를 갖는 메서드
ex) execution(Integer read*(Integer, ..))
=> 리턴 값이 Integer이고 메서드 이름이 read로 시작하며 첫번째 파라미터 타입이 Integer이고, 1개 이상의 파라미터를 갖는 메서드
